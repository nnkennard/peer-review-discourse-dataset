
<HTML>
   <head>
      <title> Review-rebuttal segmentation viewer </title>
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma-rtl.min.css">
   </head>
   <body>
 <div class="container">

 <h2 class="title is-2"> Segmentations for HygLj-cG9B </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>The paper presents a way to learn a vectorial representation for items which are only described by triplet similiarity expressions.<br><br><br><br></td><td></td><td>paper|representation|items</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>The paper not only claims 'large scale representation learning' but also utilizing the described idea to use neural networks to "directly, approximately solve non-convex NP-hard optimization problems that arise naturally in unsupervised learning problems." Both claims are not really shown in the paper: (i) The experiments are not large scale and (ii)  it becomes not clear how any substantiate insight with respect to NP-hard problems can be gained here apart from the fact that it tackles a ML problem, which many seem to be computationally hard problems.<br><br><br><br></td><td>*</td><td>5 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>As such the paper is not convincing.</td><td></td><td>5 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>On a more detailed level it is not clear why the log n representation for items is choosen -- why not just map to embeddings directly?</td><td>@</td><td>4 poss. segments</td><td>request|explanation</td><td>*</td></tr>
<tr><td>The more interesting question of how to generalize to unseen items (how would that be possible given that items have no representation at all) is not discussed at all and seems not to be realizable, which makes the starting point of such methods (items have no representation) questionable.<br><br><br><br></td><td>*</td><td>paper|learning</td><td>evaluative</td><td>*</td></tr>
<tr><td>The paper also misses relevant citations of similar questions from the field of (probabilistic) matrix factorization and relational learning.</td><td>@</td><td></td><td>evaluative</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Thanks for your feedback.</td><td></td><td></td><td>social</td><td>*</td></tr>
<tr><td>We discuss each comment in the following:<br><br><br><br></td><td></td><td>we|comment</td><td>structuring</td><td>*</td></tr>
<tr><td>- The experiments are not large scale<br><br><br><br></td><td>*</td><td>we|comment|experiments|scale</td><td>structuring</td><td>*</td></tr>
<tr><td>We respectfully disagree with the reviewer's main comment that the experiments are not large scale.</td><td>*</td><td>we|experiments|scale|reviewer</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>One needs to see the background of existing work: Existing ordinal embedding methods are known to be notoriously slow and embedding more than 10,000 points is not practical - as reflected in our experiments (see Figure 4).</td><td>*</td><td>8 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Our new approach manages to get one order of magnitude higher (100000 many points and about 4 million triplets), without diverting to heuristics such subsampling or adding extra information such as invoking active oracles (as needed in landmark approaches).</td><td>*</td><td>9 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Sure, this is not the scale of 80 million tiny images; but one wouldn’t ask an author of an improved SAT-solving algorithm, say, to scale to 80 million instances.<br><br><br><br></td><td>*</td><td>10 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Representation learning, the topic of this conference, has many facets.</td><td>*</td><td>12 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>Learning representations from “big data” (as in 80 million images with RGB representations) is one side, but learning representations when little data is available (no explicit representation, just binary-valued triplet comparisons) is the other side.</td><td>*</td><td>13 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>Both are valuable in different circumstances.<br><br><br><br></td><td>*</td><td>13 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>- No substantiate insight with respect to NP-hard problems<br><br><br><br></td><td>*</td><td>15 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>We would like to clarify that our claim was merely that we use neural networks to address ONE instance of an NP-hard optimization problem.</td><td>*</td><td>19 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>We want to bring attention to the generic idea of using neural networks as optimization toolboxes to directly solve non-convex optimization objectives instead of merely for learning problems.<br><br></td><td>*</td><td>20 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>To elaborate, consider optimization problems that arise in unsupervised learning - for instance, ordinal embedding objectives, clustering objectives or dimensionality reduction objectives.</td><td>*</td><td>18 poss. segments</td><td>summary</td><td>@</td></tr>
<tr><td>These optimization problems are typically not solved directly since there are non-convex, discrete, NP-hard.</td><td>*</td><td>17 poss. segments</td><td>summary</td><td>@</td></tr>
<tr><td>Instead, we resort to convex relaxations and many convex relaxations do not come with any guarantees.</td><td>*</td><td>19 poss. segments</td><td>summary</td><td>@</td></tr>
<tr><td>Consider, however, if we could use a non-convex optimization toolbox to directly tackle the original optimization problem - which is currently NOT the standard practice in ML.</td><td>*</td><td>20 poss. segments</td><td>summary</td><td>@</td></tr>
<tr><td>Then the value of the true objective already informs us of how close we are to the optimal solution of the optimization problem.</td><td>*</td><td>18 poss. segments</td><td>summary</td><td>@</td></tr>
<tr><td>So powerful non-convex solvers might be of a significant advantage over convex relaxations.</td><td>*</td><td>17 poss. segments</td><td>summary</td><td>@</td></tr>
<tr><td>Our paper simply shows ONE example for this.<br><br><br><br></td><td>*</td><td>19 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>- It is not clear why the log n representation for items is chosen -- why not just map to embeddings directly?<br><br><br><br></td><td>@</td><td>23 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>It would not be possible to set the input dimension the same as the embedding dimension.<br><br></td><td>@</td><td>25 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Our experiments demonstrate that we need input representations of size at least Omega (log n) to sufficiently reduce the triplet error.</td><td>@</td><td>22 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>The size of the embedding dimension can be too low to achieve this.</td><td>@</td><td>20 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>One could argue that instead of using a small network like ours, a heavily over-parameterized neural network could potentially accomplish the same with smaller input representation.</td><td>@</td><td>19 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>However, the computational complexity of the method is significantly affected by this and this is in conflict with the main goal of the paper: scaling ordinal embedding.<br><br><br><br></td><td>@</td><td>19 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>- Methods, where items have no representation, are questionable<br><br><br><br></td><td>*</td><td>18 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Items having no representation is a caveat of the data available rather than that of the method.</td><td>*</td><td>16 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>The representationless framework of triplets is relevant to many applications (e.g. crowdsourcing), and the whole field of comparison-based learning works in this framework.<br><br><br><br></td><td>*</td><td>17 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>- How to generalize to unseen items<br><br><br><br></td><td>*</td><td>17 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>First, it is not standard practice to discuss the generalization to unseen instances in unsupervised machine learning problems, for example in the literature on clustering. But of course, if generalization exists, it is of advantage.<br><br></td><td>*</td><td>13 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>We believe that in our case, generalization is realizable.</td><td>*</td><td>12 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>One possible approach would be to reserve some extra bits in the binary representation of inputs, and then utilize it to represent new items.</td><td>*</td><td>9 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>The network can be trained with extra batches of triplets which involves the new items.<br><br><br><br></td><td>*</td><td>6 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>- The paper also misses relevant citations of similar questions from the field of (probabilistic) matrix factorization and relational learning.<br><br><br><br></td><td>@</td><td>6 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>We don’t really see a link to matrix factorization or relational learning. If the reviewer has some idea of such connections, we would be happy to learn of this.</td><td>@</td><td></td><td>followup</td><td>*</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for S1xGt0Rq3m </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>The authors proposed meta domain adaptation to address domain shift scenario in meta learning setup.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>The proposed model combines few shot meta-learning with the adversarial domain adaptation to demonstrate performance improvements in several experiments.<br><br><br><br></td><td></td><td>10 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Pros:<br><br></td><td></td><td>10 poss. segments</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>1. A new few shot learning with domain shift problem is studied in the paper.<br><br></td><td></td><td>12 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>2. A new model combining prototypical network with GAN and cycle-consistency loss for addressing meta-learning domain shift scenario.</td><td></td><td>11 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>The experimental improvements on omniglot seem quite substantial.<br><br><br><br></td><td></td><td>11 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Cons:<br><br></td><td></td><td>11 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>1. Can you clarify why the proposed approach is better than the Meta-RevGrad baseline?</td><td>*</td><td>14 poss. segments</td><td>request|clarification</td><td>@</td></tr>
<tr><td>It seems that both are using meta-learning with domain adaptation technique.</td><td>*</td><td>14 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>What happen for Meta-RevGrad + idt or Meta-RevGrad + revMap?</td><td>*</td><td>13 poss. segments</td><td>request|experiment</td><td>@</td></tr>
<tr><td>I feel the baseline in domain adaptation area is a bit limited.<br><br></td><td>*</td><td>13 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>2. How is the performance of a simpler baseline such as combining a subset of new domain as training set to train MAML or PN (probably in 5-shot, 5-class case)?<br><br></td><td>*</td><td>11 poss. segments</td><td>request|experiment</td><td>@</td></tr>
<tr><td>3. It seems the domain shift in the paper is less dramatic.</td><td>*</td><td>10 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>i.e., omniglot <-> omniglot-M. I wonder whether the proposed approach can still work in large domain shift such as omniglot to fashion-mnist etc.<br><br></td><td>*</td><td>meta|model|problem|it|training</td><td>request|experiment</td><td>@</td></tr>
<tr><td>4. The novelty of the model is relatively limited as it is a combination of previous techniques on a new problem.<br><br><br><br></td><td></td><td>meta|it|training</td><td>evaluative</td><td>@</td></tr>
<tr><td>Minor:<br><br></td><td></td><td>meta|it|training</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>1. Where is L_da in Figure 2? In Figure 2, what’s the unlabelled data from which testing tasks are drawn? Is it from meta-test data training set?<br><br></td><td>@</td><td>figure</td><td>request|clarification</td><td>*</td></tr>
<tr><td>2. In the caption of figure 2, there should be a space after `":".</td><td>@</td><td></td><td>request|typo</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Overall:<br><br></td><td></td><td></td><td>structuring</td><td>*</td></tr>
<tr><td>We thank you for your time and appreciating the strengths of our work.</td><td></td><td>we|you|work</td><td>social</td><td>*</td></tr>
<tr><td>Based on your guidance and suggestions, we have tried to do additional experiments to improve the quality of our work.<br><br><br><br></td><td></td><td>we|you|suggestions|experiments</td><td>done</td><td>*</td></tr>
<tr><td>Concern 1: Comparison to Meta-RevGrad<br><br></td><td>*</td><td>7 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Meta-RevGrad tries to achieve feature invariance at the embedding level.</td><td>*</td><td>9 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Achieving such feature invariance for high-dimensional feature mapping can be a very weak constraint [1], causing limitation in performance.</td><td>*</td><td>8 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Recently, generative approaches, following image-to-image translation have been shown achieve better domain adaptation, as this constrains the feature embedding to generate the data in a new domain.</td><td>*</td><td>11 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Being a non-GAN based approach, concepts such idt (encouraging the styling network to behave as an identity when given a target domain instance as input) and revMap (constructing source instance back from generated target instance) are not applicable in this scenario, as no instances or images are being generated from a feature embedding.<br><br><br><br></td><td>*</td><td>11 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Concern 1, 2, 3: Experiments<br><br></td><td></td><td>9 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Thank you for these suggestions.</td><td>@</td><td>7 poss. segments</td><td>concede-criticism</td><td>@</td></tr>
<tr><td>Taking your comments and comments from other reviewers into account, we have made improvements to the experimental section.</td><td>@</td><td>7 poss. segments</td><td>done</td><td>@</td></tr>
<tr><td>Specifically:<br><br><br><br></td><td>@</td><td>7 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>“Domain Adaptation Baselines”,<br><br></td><td>@</td><td>8 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>We have now added additional domain adaptation baselines, designed in the setting suggested by Reviewer 2.<br><br><br><br></td><td>@</td><td>8 poss. segments</td><td>done</td><td>*</td></tr>
<tr><td>“Simple baseline – combining a subset of a new domain as training set”<br><br></td><td>*</td><td>10 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>We see the merit of this baseline, but there are several challenges in executing this.</td><td>*</td><td>9 poss. segments</td><td>reject-request</td><td>*</td></tr>
<tr><td>Designing it in a fair way is tricky.</td><td>*</td><td>10 poss. segments</td><td>reject-request</td><td>*</td></tr>
<tr><td>Using some labelled data in target domain maybe unfair, as we are not allowed to see meta-test data.</td><td>*</td><td>10 poss. segments</td><td>reject-request</td><td>*</td></tr>
<tr><td>Moreover, this is likely to not work, as the meta-train data would be too large, and would dominate, and we do not have a clear way to set the weights.<br><br><br><br></td><td>*</td><td>9 poss. segments</td><td>reject-request</td><td>*</td></tr>
<tr><td>“Dramatic Domain Shift, Omniglot to Fashion-MNIST”<br><br></td><td>@</td><td>9 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>This could be an interesting setting, but we don’t think this will work very well, as the tasks are themselves completely different. We would not expect a character recognition model to transfer to a object recognition task, as the visual features are very different.<br><br><br><br><br><br></td><td>@</td><td>8 poss. segments</td><td>reject-request</td><td>*</td></tr>
<tr><td>Minor:<br><br></td><td></td><td>8 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Thanks for this; we have updated the draft to make the presentation clearer.</td><td>*</td><td>7 poss. segments</td><td>done</td><td>@</td></tr>
<tr><td>Unlabelled data refers to only the domain of the meta-test data, but the meta-test data is never used in meta-training.<br><br></td><td>*</td><td>domain|adaptation|approach</td><td>answer</td><td>@</td></tr>
<tr><td>L_da is essentially the sum of L_gan and L_cycle.<br><br><br><br><br><br></td><td>*</td><td>domain|adaptation|approach</td><td>answer</td><td>@</td></tr>
<tr><td>[1] Shu, R., Bui, H.H., Narui, H. and Ermon, S. A DIRT-T Approach to Unsupervised Domain Adaptation. ICLR 2018</td><td></td><td></td><td>other</td><td>@</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for r1x7498kcS </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>This paper explores self-supervised learning in the low-data regime, comparing results to self-supervised learning on larger datasets.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>BiGAN, RotNet, and DeepCluster serve as the reference self-supervised methods.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>It argues that early layers of a convolutional neural network can be effectively learned from a single source image, with data augmentation.</td><td></td><td>10 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>A performance gap exists for deeper layers, suggesting that larger datasets are required for self-supervised learning of useful filters in deeper network layers.<br><br><br><br></td><td></td><td>9 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>I believe the primary claim of this paper is neither surprising nor novel.</td><td></td><td>9 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>The long history of successful hand-designed descriptors in computer vision, such as SIFT [Lowe, 1999] and HOG [Dalal and Triggs, 2005], suggest that one can design (with no data at all) features reminiscent of those learned in the first couple layers of a convolutional neural network (local image gradients, followed by characterization of those gradients over larger local windows).<br><br><br><br></td><td>*</td><td>7 poss. segments</td><td>fact</td><td>*</td></tr>
<tr><td>More importantly, it is already well established that it is possible to learn, from only a few images, filter sets that resemble the early layers of filters learned by CNNs.</td><td></td><td>7 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>This paper fails to account for a vast amount of literature on modeling natural images that predates the post-AlexNet deep-learning era.<br><br><br><br></td><td></td><td>7 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>For example, see the following paper (over 5600 citations according to Google scholar):<br><br><br><br></td><td></td><td>7 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>[1] Bruno A. Olshausen and David J. Field.</td><td>@</td><td>8 poss. segments</td><td>other</td><td>@</td></tr>
<tr><td>Emergence of simple-cell receptive field properties by learning a sparse code for natural images.</td><td>@</td><td>7 poss. segments</td><td>other</td><td>@</td></tr>
<tr><td>Nature, 1996.<br><br><br><br></td><td>@</td><td>7 poss. segments</td><td>other</td><td>@</td></tr>
<tr><td>Figure 4 of [1] shows results for learning 16x16 filters using "ten 512x512 images of natural scenes".</td><td></td><td>7 poss. segments</td><td>fact</td><td>*</td></tr>
<tr><td>Compare to the conv1 filters in Figure 2 of the paper under review.</td><td></td><td>6 poss. segments</td><td>fact</td><td>*</td></tr>
<tr><td>This 1996 paper clearly established that it is possible to learn such filters from a small number of images.</td><td></td><td>paper|learning|it|history</td><td>fact</td><td>*</td></tr>
<tr><td>There is long history of sparse coding and dictionary learning techniques, including multilayer representations, that follows from the early work of [1].</td><td></td><td>paper|it|history</td><td>fact</td><td>*</td></tr>
<tr><td>The paper should at minimum engage with this extensive history, and, in light of it, explain whether its claims are actually novel.</td><td>*</td><td></td><td>evaluative</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>We hope that the reviewer will change his opinion once we clarify the goal of our paper and explain how it relates to prior work, as we believe we are fundamentally on the same page.<br><br><br><br></td><td></td><td>7 poss. segments</td><td>social</td><td>*</td></tr>
<tr><td>We are well aware of SIFT, HOG, the results of Olshausen and Field on learning image filters from a few example images (some of us are sufficiently old to have implemented all such methods from scratch as grad students!) and no annotations, as well as Mallat’s Scattering nets [1].</td><td>*</td><td>12 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>In fact, we discuss and evaluate Oyallon’s 2017 implementation [2] of this at page 5 and table 2 in the paper.<br><br><br><br></td><td>*</td><td>14 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>However, the existence of these methods does not detract from the message of this paper.</td><td>*</td><td>15 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>Our goal is to provide “critical analysis” of current self-supervision methods because these *specific* tools are now very heavily researched.</td><td>*</td><td>15 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>Our paper sends a cautionary message: current self-supervised learning techniques cannot improve on what can be obtained from a single image plus transformations for early layers in a network, and only improves in a limited manner for deeper layers, despite ingesting millions of images (which is touted as their key advantage).</td><td>*</td><td>16 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>In particular, the claims are not limited to the first few layers as we show that one image recovers two thirds of the performance of deeper layers as well.</td><td>*</td><td>17 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>This message, which is a partially negative result, stands on its own, regardless of whether good low-level features can be obtained in some other ways (e.g. manually) and, we hope the reviewer will agree, should be known by the community.<br><br><br><br></td><td>*</td><td>17 poss. segments</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>Nevertheless, we also agree with the reviewer that it is interesting to put these findings in a broader context, so we are happy to expand the discussion of prior feature learning/design work further.</td><td>*</td><td>14 poss. segments</td><td>by-cr</td><td>*</td></tr>
<tr><td>However, please note that none of this literature makes our specific findings on the limits of self-supervision obvious.</td><td>*</td><td>13 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Furthermore, although this is a little besides the point, in the paper we do show in Table 2 that scattering transforms works as well as conv1, but that from conv2 onwards self-supervision on a single image does better, so even the claim that handcrafted features are equivalent to the first few layers in deep networks is not proven.</td><td>*</td><td>7 poss. segments</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Also, the fact that Olshausens’s filters resemble conv1 does not mean that they are equivalent to conv1 in recognition performance.<br><br><br><br></td><td>*</td><td>mallat|oyallon|networks</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>—<br><br></td><td></td><td>mallat|oyallon|networks</td><td>structuring</td><td>*</td></tr>
<tr><td>[1] J. Bruna and S. Mallat. "Invariant scattering convolution networks." TPAMI 2013<br><br></td><td></td><td>oyallon|networks</td><td>other</td><td>*</td></tr>
<tr><td>[2] E. Oyallon, et al. "Scaling the scattering transform: Deep hybrid networks." ICCV 2017</td><td></td><td></td><td>other</td><td>*</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for S1xAWnjRFH </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Summary:<br><br><br><br></td><td></td><td></td><td>structuring|heading</td><td>*</td></tr>
<tr><td>This paper makes an observation that most of the neural network architectures do not learn the mutual exclusivity (ME) bias: if an object has one label, then it does not need another.</td><td></td><td>paper|me|bias|object|it</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Authors demonstrate this in both synthetic tasks and real-world tasks like object recognition and machine translation.</td><td></td><td>paper|me|bias|it|authors</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Authors argue that ME bias could help the model to handle new classes and rare events better.<br><br><br><br></td><td></td><td>paper|me|bias|it|authors</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>My comments:<br><br><br><br></td><td></td><td>6 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>I very much enjoyed reading this paper.</td><td></td><td>7 poss. segments</td><td>social</td><td>@</td></tr>
<tr><td>I support accepting this paper.</td><td></td><td>me|bias|it|authors|comments|i</td><td>social</td><td>@</td></tr>
<tr><td>It highlights one of the missing inductive biases in ML and proposes it as a challenge.</td><td></td><td>7 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>As the authors also agree, ME bias is missing not just in DNNs.</td><td></td><td>7 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>It is the issue of MLE.</td><td></td><td>8 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>It would be good to have some non-NN results too.</td><td></td><td>9 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>I see this is a challenge for MLE than DNNs.<br><br><br><br></td><td></td><td>7 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>1. In figure-4 you mention that entropy regularizer helps to keep the initial ME score. Can you elaborate more about the way in which entropy regularizer is used with regular MLE training?<br><br></td><td>*</td><td>7 poss. segments</td><td>request|explanation</td><td>@</td></tr>
<tr><td>2. It is not very clear how is the base rate computed in Figure 5. I have a guess. But it is better to explain it in detail.<br><br></td><td>@</td><td>authors|comments|i|results|you</td><td>request|explanation</td><td>@</td></tr>
<tr><td>3. Section 4.2 need more clarity. For example, what do you mean by classifying the image as “new”? Is “new” a class name? Also, how is P(N|t) computed? Please explain.<br><br></td><td>*</td><td>6 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>4. Are the authors willing to release the code and data to reproduce the results?<br><br><br><br></td><td></td><td>5 poss. segments</td><td>request|explanation</td><td>@</td></tr>
<tr><td>Minor comments:<br><br><br><br><br><br></td><td>@</td><td>authors|i|section|class</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>1. Page 3: second para, line 4: “our aim is to study”<br><br></td><td></td><td>6 poss. segments</td><td>request|edit</td><td>*</td></tr>
<tr><td>2. Page 5: last line: estimate for -> estimated for<br><br></td><td></td><td>authors|i|section|class|line</td><td>request|edit</td><td>*</td></tr>
<tr><td>3. Section 4.2: 3rd line: “the class for the from”<br><br><br><br></td><td></td><td>authors|i</td><td>request|edit</td><td>*</td></tr>
<tr><td>=====================================================<br><br><br><br></td><td></td><td>authors|i</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>After rebuttal: I have read the authors' response and  I stand by my decision.</td><td></td><td></td><td>social</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Thank you for your supportive review.<br><br></td><td></td><td></td><td>social</td><td>*</td></tr>
<tr><td>We answer the specific queries below and have also added them to the revised version of the paper.<br><br></td><td></td><td>we|paper</td><td>structuring</td><td>*</td></tr>
<tr><td>1.         We found that the entropy regularizer produces an ME score that stays constant across training, at the cost of the model being less confident about predictions made for seen classes.</td><td>*</td><td>5 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>We added details regarding this condition to the manuscript.<br><br></td><td>*</td><td>5 poss. segments</td><td>done</td><td>*</td></tr>
<tr><td>2.         The base rate is the probability of observing a new word in the target at that particular point in training.</td><td>@</td><td>10 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>We go through the remaining sentences in the corpus from the target compute the probability of sampling a sentence with at least one new word.</td><td>@</td><td>10 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Thus, the base rate at time t in training is defined as:<br><br></td><td>@</td><td>8 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>$$P(\text{new in target at t}) = \frac{ \text{# of unseen sentences in target with new words}} {\text{# of unseen sentences}}$$<br><br></td><td>@</td><td>7 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>3.</td><td>@</td><td>7 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>In Section 4.2, we use “new” to refer to the set of all the unseen classes at a particular timepoint t.</td><td>*</td><td>7 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>For the classifier, P(N|t) is calculated by adding the probabilities the model assigns to all the “new” classes when iterating through the remaining corpus (similar to Equation 1 in our paper).</td><td>*</td><td>we|paper|classes|corpus|t|p|n</td><td>answer</td><td>*</td></tr>
<tr><td>For the dataset, we compute P(N|t) by sampling all unseen images in the corpus and compute the proportion from “new” classes given their ground truth labels.<br><br></td><td>*</td><td>we|paper</td><td>answer</td><td>*</td></tr>
<tr><td>4.         We will release our code and data with the publication of the paper.</td><td>@</td><td>we</td><td>answer</td><td>*</td></tr>
<tr><td>Most of our experiments are easy to replicate as they use standard datasets, models, loss functions and optimizers.</td><td>@</td><td>we</td><td>answer</td><td>*</td></tr>
<tr><td>We sincerely hope that our challenge and these resources will stimulate progress in this area.<br><br><br><br></td><td></td><td>we</td><td>social</td><td>*</td></tr>
<tr><td>Please also see above where we write a general response to all reviews.</td><td></td><td></td><td>social</td><td>@</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for Skx7vDii3X </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>This paper proposes to address few-shot learning in a transductive way by learning a label propagation model in an end-to-end manner.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Semi-supervised few-shot learning is important considering the limitation of the very few labeled instances.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>This is an interesting work.<br><br><br><br></td><td></td><td>7 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>The merits of this paper lie in the following aspects: (1) It is the first to learn label propagation for transductive few-shot learning.</td><td></td><td>8 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>(2) The proposed approach produced effective empirical results.<br><br><br><br></td><td></td><td>9 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>The drawbacks  of the work include the following: (1) There is not much technical contribution.</td><td>*</td><td>9 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>It merely just puts the CNN representation learning and the label propagation together to perform end-to-end learning.</td><td>*</td><td>8 poss. segments</td><td>fact</td><td>*</td></tr>
<tr><td>Considering the optimization problem involved in the learning process, it is hard to judge whether the effect of such a procedure from the optimization perspective.</td><td>*</td><td>7 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>(2) Empirically, it seems TPN achieved very small improvements over the very baseline label propagation.</td><td>@</td><td>paper|shot|work|results</td><td>structuring|quote</td><td>*</td></tr>
<tr><td>Moreover, the performance reported in this paper seems to be much inferior to the state-of-the-art results reported in the literature.</td><td>@</td><td>shot|work|results</td><td>evaluative</td><td>*</td></tr>
<tr><td>For example,  on miniImageNet, TADAM(Oreshkin et al, 2018) reported 58.5 (1-shot) and 76.7(5-shot), which are way better than the results reported in this work.</td><td>@</td><td></td><td>fact</td><td>*</td></tr>
<tr><td>This is a major concern.</td><td>@</td><td></td><td>fact</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Please refer to our main response in an above comment that addresses the primary and common questions amongst all reviewers.</td><td></td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>Here we respond to your specific comments.<br><br><br><br></td><td></td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>"(1) There is not much technical contribution. It merely just puts the CNN representation learning and the label propagation together to perform end-to-end learning. Considering the optimization problem involved in the learning process, it is hard to judge whether the effect of such a procedure from the optimization perspective."<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>>>> As mentioned in the main response, the proposed TPN is not a mere combination of CNN representation learning and label propagation.</td><td>*</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>The original label propagation constructs a fixed graph (Eq (1)) to explore the correlation between examples.</td><td>*</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>While in our work, we adaptively construct the graph structure for each episode (training task) with a learnable graph construction module (Figure 4, Appendix A).</td><td>*</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>This leads to better generalization ability for test tasks.<br><br></td><td>*</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>In Table 1 and Table 2, the proposed TPN achieved much higher accuracy than the mere combination model (referred to as "Label Propagation").<br><br><br><br></td><td>*</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>"</td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>(2) Empirically, it seems TPN achieved very small improvements over the very baseline label propagation.</td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>Moreover, the performance reported in this paper seems to be much inferior to the state-of-the-art results reported in the literature.</td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>For example,  on miniImageNet, TADAM(Oreshkin et al, 2018) reported 58.5 (1-shot) and 76.7(5-shot), which are way better than the results reported in this work.</td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>This is a major concern."<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>>>> At first, we want to clarify the few-shot network architecture setting.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Currently, there are two common network architectures: 4-layer ConvNets (e.g., [1][2][3]) and 12-layer ResNet (e.g., [4][5][6][7]).</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Our method belongs to the first one, which contains much fewer layers than the ResNet setting.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Thus, it is more reasonable to compare TADAM with ResNet version of our method.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>To better relieve the reviewer's concern, we implemented our algorithm with ResNet architecture on miniImagenet dataset and show the results as follow:<br><br><br><br></td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Method</td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>1-shot    5-shot<br><br></td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>SNAIL [4]</td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>55.71     68.88<br><br></td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>adaResNet [5]                        56.88     71.94<br><br></td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>Discriminative k-shot [6]</td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>56.30     73.90<br><br></td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>TADAM [7]</td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>58.50     76.70<br><br></td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>--------------------------------------------------------<br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>Ours</td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>59.46     75.65<br><br></td><td>@</td><td>None</td><td>summary</td><td>@</td></tr>
<tr><td>--------------------------------------------------------<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>It can be seen that we beat TADAM for 1-shot setting.</td><td>@</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>For 5-shot, we outperform all other recent high-performance methods except for TADAM.<br><br><br><br></td><td>@</td><td>None</td><td>reject-criticism</td><td>@</td></tr>
<tr><td>>>> We want to clarify that "Label Propagation" in Table 1 and Table 2 is a strong baseline.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>It combines label propagation method [8] with episodic meta-learning.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>The usage of transductive inference makes this baseline outperform most published state-of-the-art methods.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>Moreover, the performance of TPN over label propagation is not very small.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>For example, in miniImagenet, TPN outperforms label propagation with 1.44% and 1.25% for 1-shot and 5-shot respectively, but this advantage grows to 3.20% and 1.68% with "Higher Shot" training.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>The improvements are even larger for tieredImagenet with 4.68% and 2.87%.</td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>We believe in few-shot learning, this is a large improvement.<br><br><br><br><br><br></td><td>@</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>[1] Finn, Chelsea, Pieter Abbeel, and Sergey Levine. "Model-agnostic meta-learning for fast adaptation of deep networks." ICML. 2017.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[2] Snell, Jake, Kevin Swersky, and Richard Zemel. "Prototypical networks for few-shot learning." NIPS. 2017.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[3] Yang, Flood Sung Yongxin et al. "Learning to compare: Relation network for few-shot learning." CVPR. 2018.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[4] Mishra, Nikhil et al. "A simple neural attentive meta-learner." ICLR. 2018.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[5] Munkhdalai, Tsendsuren et al. "Rapid adaptation with conditionally shifted neurons." ICML. 2018.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[6] Bauer, Matthias et al. "Discriminative k-shot learning using probabilistic models." arXiv. 2017.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[7] Oreshkin, B.N., Lacoste, A. and Rodriguez, P., 2018. "TADAM: Task dependent adaptive metric for improved few-shot learning." NIPS. 2018.<br><br></td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>[8] Zhou, Denny, et al. "Learning with local and global consistency." NIPS. 2004.</td><td></td><td>None</td><td>other</td><td>*</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for SJgAEEpDhQ </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Summary:<br><br><br><br></td><td></td><td></td><td>structuring|heading</td><td>*</td></tr>
<tr><td>This paper addresses the computational aspects of Viterbi-based encoding for neural networks.<br><br><br><br></td><td></td><td>paper|viterbi</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>In usual Viterbi codes, input messages are encoded via a convolution with a codeword, and then decoded using a trellis.</td><td></td><td>paper|viterbi|codes|messages</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Now consider a codebook with n convolutional codes, of rate 1/k.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Then a vector of length n is represented by inputing a message of length k and receiving n encoded bits.</td><td></td><td>7 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Then the memory footprint (in terms of messages) is reduced by rate k/n.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>This is the format that will be used to encode the row indices in a matrix, with n columns.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>(The value of each nonzero is stored separately.)</td><td></td><td>8 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>However, it is clear that not all messages are possible, only those in the "range space" of my codes. (This part is previous work Lee 2018.)<br><br><br><br></td><td></td><td>9 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>The "Double Viterbi" (new contribution) refers to the storage of the nonzero values themselves.</td><td></td><td>10 poss. segments</td><td>structuring|summary</td><td>@</td></tr>
<tr><td>A weakness of CSR and CSC (carried over to the previous work) is that since each row may have a different number of nonzeros, then finding the value of any particular nonzero requires going through the list to find the right corresponding nonzero, a sequential task.</td><td></td><td>8 poss. segments</td><td>structuring|summary</td><td>@</td></tr>
<tr><td>Instead, m new Viterbi decompressers are included, where each row becomes (s_1*codeword_1 + s_2*codeword2 + ...) cdot mask, and the new scalar are the results of the linear combinations of the codewords.<br><br><br><br></td><td></td><td>7 poss. segments</td><td>structuring|summary</td><td>@</td></tr>
<tr><td>Pros:<br><br></td><td></td><td>7 poss. segments</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>- I think the work addressed here is important, and though the details are hard to parse and the new contributions seemingly small, it is important enough for practical performance.<br><br></td><td></td><td>8 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>- The idea is theoretically sound and interesting.<br><br><br><br></td><td></td><td>9 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Cons:<br><br></td><td></td><td>9 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>- My biggest issue is that there is no clear evaluation of the runtime benefit of the second Viterbi decompressor.</td><td>*</td><td>8 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>Compressability is evaluated, but that was already present in the previous work.</td><td>*</td><td>7 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>Therefore the novel contribution of this paper over Lee 2018 is not clearly outlined.<br><br></td><td>*</td><td>paper|terms|it|i|idea</td><td>evaluative</td><td>@</td></tr>
<tr><td>- It is extremely hard to follow what exactly is going on; I believe a few illustrative examples would help make the paper much clearer; in fact the idea is not that abstract.<br><br></td><td>@</td><td>terms</td><td>evaluative</td><td>@</td></tr>
<tr><td>- Minor grammatical mistakes (missing "a" or "the" in front of some terms, suggest proofread.)</td><td>*</td><td></td><td>request|typo</td><td>@</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Thank you very much for the positive comments.</td><td></td><td>None</td><td>social</td><td>*</td></tr>
<tr><td>We added the more experimental data of runtime analysis to address the Reviewer's main concern.<br><br><br><br></td><td>*</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>Q1. My biggest issue is that there is no clear evaluation of the runtime benefit of the second Viterbi decompressor.</td><td>*</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>Compressability is evaluated, but that was already present in the previous work.</td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>Therefore the novel contribution of this paper over [1] is not clearly outlined.<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>We conducted additional simulations to evaluate the runtime benefit of the proposed method compared to that of the method in [1].</td><td>*</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>We generated random 512-by-512 matrices with pruning rate ranging from 70 % to 95 % and simulated the number of parameters fed to PEs in 10000 cycles.</td><td>*</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>The assumptions used for the simulation and analysis data have been updated in Figure 6c of the revised manuscript.</td><td>*</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>We could observe that proposed parallel weight decoding based on the second Viterbi decompressor allowed 10 % to 40 % more parameters to be fed to PEs than the previous design [1].</td><td>*</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>The proposed method outperformed both baseline method and [1] in all simulation results.</td><td>*</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>Please note that the data described in Figure 6c has been updated from Figure 7, and our method shows better performance in new data compared to the data shown in the original manuscript.</td><td>*</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>While preparing for the rebuttal, we realized that our simulation model did not fully exploit the parallelized weight and index decoding process of the proposed method.</td><td>*</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>After further optimization, we could observe that the parameter feeding rate of the proposed method increased compared to the reported data in original manuscript.</td><td>*</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>Therefore, we updated Figure 7 in original manuscript to Figure 6c in the updated manuscript according to the new data.<br><br><br><br></td><td>*</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>Q2. It is extremely hard to follow what exactly is going on; I believe a few illustrative examples would help make the paper much clearer; in fact the idea is not that abstract.<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>In the revision, we added the more precise mathematical description of the input and output of each block in Figure 1 and showed the change of the exact weight representation at each process.</td><td>@</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>We first prune weights in a neural network with the Viterbi-based pruning scheme [1], then we quantize the pruned weights with the alternating quantization method [2].</td><td>@</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>Our main contribution is the third process, which includes encoding each weight with the Viterbi algorithm, and retraining for the recovery of accuracy.</td><td>@</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>With our proposed method, the sparse and encoded weights are reconstructed to a dense matrix as described in Figure 2.</td><td>@</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>Figure 2 illustrates the purpose of our proposed scheme, which is the parallelization of the whole sparse-to-dense conversion process with the VDs while maintaining the high compression rate.<br><br><br><br></td><td>@</td><td>None</td><td>summary</td><td>*</td></tr>
<tr><td>Q3. Minor grammatical mistakes (missing "a" or "the" in front of some terms, suggest proofread.)<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>Thanks very much for the suggestions.</td><td>*</td><td>None</td><td>concede-criticism</td><td>@</td></tr>
<tr><td>We tried to fix grammatical mistakes as much as possible in the revision.<br><br><br><br></td><td>*</td><td>None</td><td>done</td><td>@</td></tr>
<tr><td>Reference<br><br></td><td></td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>[1] Dongsoo Lee, Daehyun Ahn, Taesu Kim, Pierce I. Chuang, and Jae-Joon Kim. Viterbi-based pruning for sparse matrix with fixed and high index compression ratio. International Conference on Learning Representations (ICLR), 2018.<br><br></td><td></td><td>None</td><td>other</td><td>@</td></tr>
<tr><td>[2] Chen Xu, Jianqiang Yao, Zouchen Lin, Wenwu Qu, Yuanbin Cao, Zhirong Wang, and Hongbin Zha. Alternating multi-bit quantization for recurrent neural networks. International Conference on Learning Representations (ICLR), 2018.</td><td></td><td>None</td><td>other</td><td>@</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for H1x3aUom2X </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>This paper is well set-up to target the interesting problem of degraded generalisation after adversarial training.</td><td></td><td>paper|problem|generalisation</td><td>evaluative</td><td>*</td></tr>
<tr><td>The proposal of applying spectral normalisation (SN) is well motivated, and is supported by margin-based bounds.</td><td></td><td>6 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>However, the experimental results are weak in justifying the paper's claims.<br><br><br><br></td><td></td><td>6 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Pros:<br><br></td><td></td><td>6 poss. segments</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>* The problem is interesting and well explained<br><br></td><td></td><td>6 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>* The proposed method is clearly motivated<br><br></td><td></td><td>7 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>* The proposal looks theoretically solid<br><br><br><br></td><td></td><td>6 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Cons:<br><br><br><br></td><td></td><td>6 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>* It is unclear to me whether the "efficient method for SN in convolutional nets" is more efficient than the power iteration algorithm employed in previous work, such as Miyato et al. 2018, which also used SN in conv nets with different strides.</td><td>*</td><td>6 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>There is no direct comparison of performance.<br><br><br><br></td><td>*</td><td>6 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>* Fig. 3 needs more explanation.</td><td>@</td><td>8 poss. segments</td><td>request|explanation</td><td>@</td></tr>
<tr><td>The horizontal axes are unlabelled, and "margin normalization" is confusing when shown together with SN without an explanation.</td><td>@</td><td>5 poss. segments</td><td>request|edit</td><td>@</td></tr>
<tr><td>Perhaps it's helpful to briefly introduce it in addition to citing Bartlett et al. 2017.<br><br><br><br></td><td>@</td><td>5 poss. segments</td><td>request|edit</td><td>@</td></tr>
<tr><td>* The epsilons in Fig. 5 have very different scales (0 - 0.5 vs. 0 - 5). Are these relevant to the specific algorithms and why?<br><br><br><br></td><td>*</td><td>5 poss. segments</td><td>request|explanation</td><td>*</td></tr>
<tr><td>* Section 5.3 (Fig. 6) is the part most relevant to the generalisation problem.</td><td>@</td><td>results|it</td><td>evaluative</td><td>*</td></tr>
<tr><td>However, the results are unconvincing: only the results for epsilon = 0.1 are shown, and even so the advantage is marginal.</td><td>@</td><td>it|advantage</td><td>evaluative</td><td>*</td></tr>
<tr><td>Furthermore, the baseline models did not use other almost standard regularisation techniques (weight decay, dropout, batch-norm).</td><td>@</td><td>it|advantage</td><td>evaluative</td><td>*</td></tr>
<tr><td>It is thus unclear whether the advantage can be maintained after applying these standard regularsisers.<br><br><br><br></td><td>@</td><td></td><td>evaluative</td><td>*</td></tr>
<tr><td>A typo in page 6, last line: wth -> with</td><td></td><td></td><td>request|typo</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>We thank Reviewer 2 for the constructive feedback.</td><td></td><td>None</td><td>social</td><td>*</td></tr>
<tr><td>Here is our point-to-point response to the comments and questions raised in the review:<br><br><br><br></td><td></td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>1. “It is unclear to me whether the "efficient method for SN in convolutional nets" is more efficient than the power iteration algorithm employed in previous work, such as Miyato et al. 2018, which also used SN in conv nets with different strides. There is no direct comparison of performance.”<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>We do not claim that our method is more efficient than Miyato et al.’s method, which uses the spectral norm of the convolution kernel matrix to approximate the spectral norm of the convolution operation.</td><td>*</td><td>None</td><td>contradict-assertion</td><td>@</td></tr>
<tr><td>In fact, our proposed method is computationally more expensive than their approximate scheme because each power iteration in our method requires a conv/deconv operation rather than a simple division used by Miyato et al.’s.<br><br><br><br></td><td>*</td><td>None</td><td>contradict-assertion</td><td>@</td></tr>
<tr><td>We introduce our new spectral normalization scheme for convolutional layers because there exist examples where the true spectral norm of a convolution operation can be arbitrarily larger than Miyato et al.’s approximation.</td><td>*</td><td>None</td><td>contradict-assertion</td><td>*</td></tr>
<tr><td>Therefore, Miyato et al.’s normalization scheme is not guaranteed to control the spectral norm of convolutional layers which is critical for controlling a DNN’s generalization performance (please see our generalization bounds in Section 3).</td><td>*</td><td>None</td><td>contradict-assertion</td><td>*</td></tr>
<tr><td>To further support our argument, we performed additional experiments demonstrating how our proposed method better controls the spectral norm of convolution layers, resulting in better generalization and test performance.</td><td>*</td><td>None</td><td>contradict-assertion</td><td>*</td></tr>
<tr><td>The results are presented in Appendix A.1.</td><td>*</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>Furthermore, we run several experiments to show that our method is not significantly slower than Miyato et al.’s method, and we report the results in Appendix A.1, Table 3.<br><br><br><br></td><td>*</td><td>None</td><td>reject-criticism</td><td>*</td></tr>
<tr><td>2. “Fig. 3 needs more explanation. The horizontal axes are unlabelled, and "margin normalization" is confusing”<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>We relabel the axes and add a more thorough explanation in the caption.</td><td>@</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>We note that the text explaining Figure 3 mentions how the margin normalization is performed (paragraph 3 in section 5.1): the margin normalization factor is exactly the capacity norm \Phi described in Theorems 1-4.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>We clarify that we divide the obtained margins by the values of \Phi estimated on the dataset.<br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>3. “The epsilons in Fig. 5 have very different scales (0 - 0.5 vs. 0 - 5). Are these relevant to the specific algorithms and why?”<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>Yes, the epsilons are chosen to be different depending on whether we are looking at norm_inf attacks or norm_2 attacks.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>This is because the two norms can behave very differently in adversarial attack experiments.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>For example, a norm_inf attack of 0.5 implies that all pixels can be changed by 0.5.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>On the other hand, a norm_2 attack of 0.5 means the overall Euclidean norm of perturbation across all pixels is bounded by 0.5, resulting in a much less powerful attack.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Based on this comment, we update the plots with the same attack-norm to have the same scale.<br><br><br><br></td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>4. "Section 5.3 (Fig. 6) is the part most relevant to the generalisation problem.</td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>However, the results are unconvincing: only the results for epsilon = 0.1 are shown, and even so the advantage is marginal."<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>We redo the visualization in Figure 6 to make the gains provided by SN clearer.</td><td>@</td><td>None</td><td>done</td><td>@</td></tr>
<tr><td>We see that using SN can improve the test performance by over 12% for some FGM, PGM, and WRM cases.<br><br><br><br></td><td>@</td><td>None</td><td>done</td><td>@</td></tr>
<tr><td>5. "The baseline models did not use other almost standard regularisation techniques (weight decay, dropout, batch-norm).</td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>It is thus unclear whether the advantage can be maintained after applying these standard regularisers."<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>We did not originally discuss weight decay, dropout, and batch normalization as none of these methods were motivated by the theory we introduced in section 3.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>However, due to the reviewers’ concern in the updated draft we compare spectrally-normalized networks to networks with the same architecture except with weight decay, dropout, or batch norm in Appendix A.2.</td><td>@</td><td>None</td><td>done</td><td>@</td></tr>
<tr><td>In our experiments, the SN-regularized network still performs better in terms of test accuracy.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for ryxWDI_Gsm </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>The paper extends previous work on differentiable placticity to include neuro modulation by parameterizing the learning rate of Hebbs update rule.</td><td></td><td>paper|work|neuro|modulation</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>In addition, the authors introduce retroactive modulation that basically allows the system to delay incorporation of plasticity updates via so eligibility traces.</td><td></td><td>6 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Experiments are performaed on 2 simple toy datasets and a simple language modeling task.</td><td></td><td>11 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>A newly developed cue-reward association task shows the clear limitations of basic plasticity and how modulation can resolve this.</td><td></td><td>14 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Slight improvements can also be seen on a simple maze navigation task as well as on a basic language modeling dataset.<br><br><br><br></td><td></td><td>14 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Overall I like the motivation, provided background information and simplicity of the approach.</td><td></td><td>17 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Furthermore, the cue-reward experiment seems to be a well designed show case for neuro-modulation.</td><td></td><td>18 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>However, as the authors acknowledge the overall simplicity of the tasks being evaluated with mostly marginal improvements makes the overall evaluation fall short.</td><td></td><td>18 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Unfortunately the paper doesn't provide any qualitative analysis on how modulation is employed by the models after training.</td><td>*</td><td>20 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>Therefore, although I would like to see an extended version of this paper at the conference, without further experiments and analysis I see the current version rather as an interesting workshop contribution.<br><br><br><br><br><br></td><td>*</td><td>18 poss. segments</td><td>social</td><td>*</td></tr>
<tr><td>Strengths:<br><br></td><td></td><td>18 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>- motivation: the natural extension of previous work on differentiable plasticity based on existing knowledge from neuro science is an important next step<br><br></td><td></td><td>16 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- cue reward experiment exemplifies limitations of current plasticity approaches and clearly shows the potential benefits of neuro modulation<br><br></td><td></td><td>12 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- maze navigation shows incremental benefits over non-modulated plasticity<br><br></td><td></td><td>9 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- thorough experimentation<br><br></td><td></td><td>9 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- clipping-trick is a neat observation<br><br><br><br><br><br></td><td></td><td>9 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>Weaknesses:<br><br></td><td></td><td>9 poss. segments</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>- evaluation: only on toy tasks (which includes PTB), no real world tasks<br><br></td><td></td><td>7 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- very incremental improvements on PTB over a very simple baseline (far from SotA)<br><br></td><td>@</td><td>9 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- evaluated models (feed-forward NNs and LSTMs) are very basic and far from current SotA architectures<br><br></td><td>@</td><td>8 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>- no qualitative analysis on how modulation is actually use by the systems.</td><td>*</td><td>7 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>E.g., when is modulation strong and when is it not used<br><br><br><br><br><br></td><td>*</td><td>6 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>Comments:<br><br></td><td></td><td>6 poss. segments</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>- perplexity improvements of less than 1.3 points over plasticity alone (which is the actual baseline for this paper) can hardy be called "significant". Even though they might be statistically significant (meaning nothing more than the two models being statistically different), minor architectural changes can lead to such improvements.</td><td>@</td><td>ptb</td><td>evaluative</td><td>*</td></tr>
<tr><td>Furthermore PTB is not a "challenging" LM benchmark.</td><td>@</td><td></td><td>evaluative</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Thank you to Reviewer 3 for your thoughtful critique and we are happy that you share our enthusiasm for the motivation behind our approach.</td><td></td><td>reviewer|we</td><td>social</td><td>*</td></tr>
<tr><td>We share your curiosity on the qualitative behavior of such systems, and as documented in this response we have augmented the paper to address that and other of your suggestions.<br><br><br><br></td><td></td><td>5 poss. segments</td><td>social</td><td>*</td></tr>
<tr><td>Re: "- no qualitative analysis on how modulation is actually use by the systems.</td><td>*</td><td>5 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>E.g., when is modulation strong and when is it not used "<br><br><br><br></td><td>*</td><td>reviewer|we|response|paper|it</td><td>structuring</td><td>*</td></tr>
<tr><td>Following the reviewer’s suggestion, we have added a figure that shows the dynamics of neuromodulation in the cue-response task (Figure 3, in the Appendix).</td><td>*</td><td>8 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>This figure shows that while neuromodulation clearly reacts to reward, this reaction is complex and varies both within each episode and between runs.<br><br><br><br></td><td>*</td><td>6 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Re: "- perplexity improvements of less than 1.3 points over plasticity alone (which is the actual baseline for this paper) can hardy be called "significant".</td><td>@</td><td>6 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Even though they might be statistically significant (meaning nothing more than the two models being statistically different), minor architectural changes can lead to such improvements.</td><td>@</td><td>6 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Furthermore PTB is not a "challenging" LM benchmark."<br><br><br><br></td><td>@</td><td>7 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>We agree that, while the differences are statistically significant, they are minor.</td><td>@</td><td>6 poss. segments</td><td>mitigate-criticism</td><td>@</td></tr>
<tr><td>We were using that word technically, but do not want to give the wrong impression.</td><td>@</td><td>6 poss. segments</td><td>mitigate-criticism</td><td>@</td></tr>
<tr><td>We have thus modified the text to make it clear that we mean “statistically significant” only.</td><td>@</td><td>reviewer|we|response|task|ptb</td><td>done</td><td>@</td></tr>
<tr><td>We also removed the adjective “challenging” as regards PTB.<br><br><br><br></td><td>@</td><td>reviewer|we|response|task</td><td>done</td><td>@</td></tr>
<tr><td>We agree that, ideally, a comparison with SOTA architectures would be desirable.</td><td>*</td><td>5 poss. segments</td><td>concede-criticism</td><td>*</td></tr>
<tr><td>As explained in the response to Reviewer 1, despite all our efforts, we found the technical challenges insurmountable given our computational and engineering resources.</td><td>*</td><td>we|task|architectures</td><td>answer</td><td>*</td></tr>
<tr><td>We will keep trying to investigate such massive architectures in the future.<br><br><br><br><br><br></td><td>*</td><td>we|task</td><td>future</td><td>*</td></tr>
<tr><td>Importantly, our purpose in this task is to show that, **all other things being equal**, a neuromodulated plastic LSTM can outperform a standard LSTM in realistic settings.</td><td>*</td><td>we|task|lstm</td><td>answer</td><td>*</td></tr>
<tr><td>We believe that outperforming standard LSTMs (again, all else being equal) on their “workhorse” task domain (language processing) is worthy of notice, especially given the ease of implementation of our method which requires only adding a few lines of codes (<10) to a standard LSTM implementation and can then be used as a drop-in replacement to standard LSTM.</td><td>*</td><td></td><td>answer</td><td>*</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for HyeHzlJ537 </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>This paper describes the method for performing self-training where the unlabeled datapoints are iteratively added to the training set only if their predictions by the classifier are confident enough.</td><td></td><td>None</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>The contributions of this paper are to add datapoints based on the prediction of the confidence level by a separate selection network and a number of heuristics applied for better selection.</td><td></td><td>None</td><td>fact</td><td>*</td></tr>
<tr><td>On the experimental side, the contribution is to test the scenario where datapoints from irrelevant classes are included in the unlabeled dataset.<br><br></td><td></td><td>None</td><td>fact</td><td>*</td></tr>
<tr><td>The paper is written in a way that makes following it a bit difficult, for example, the experimental setups.</td><td>*</td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>Also, the writing can be improved by making the writing more concise and formal (examples of informal: "spoil the network", "model is spoiled", "problem of increased classes", "many recent researches have been conducted", "lots of things to consider for training", "supervised learning was trained" etc.).</td><td></td><td>None</td><td>request|edit</td><td>*</td></tr>
<tr><td>The contributions of the method could also be underlined more clearly in the abstract and introduction.</td><td></td><td>None</td><td>request|edit</td><td>*</td></tr>
<tr><td>The description of consistency regularisation methods in section 2.2 is not very clear and I would like to get better understanding of temporal ensembling and SNTG methods here as they play an important role in the experiments.<br><br></td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>The idea of selective sampling for self-training is promising and the investigated questions are interesting.</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>As far as I understand, the main contribution of this paper is the use of separate "selection network" to estimate the confidence of predictions by "classification network".</td><td>@</td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>However, as the "selection network" uses exactly the same input as "classification network", it is hard to imagine how it can learn additional information.</td><td>@</td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>For example, imagine the case of binary classification.</td><td></td><td>None</td><td>other</td><td>*</td></tr>
<tr><td>If the selection network predicts 0 in come cases, it can be used to improve the result of "classification network" by flipping the corresponding label.</td><td>*</td><td>None</td><td>fact</td><td>*</td></tr>
<tr><td>How can you interpret such a thought experiment?</td><td>*</td><td>None</td><td>request|explanation</td><td>*</td></tr>
<tr><td>One could understand the use of "selection network" as a way to automatically select a threshold of what to consider confident, however, in this case, the prediction of "selection network" should be thresholded at 0.5 (correct prediction or not), but the experiments use complex thresholds.</td><td>*</td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>Could you elaborate more on why the selection network is needed? How would it compare to a simple strategy of only including the datapoints whose top-1 prediction of "classification network" is greater than some threshold?</td><td>*</td><td>None</td><td>request|explanation</td><td>*</td></tr>
<tr><td>Finally, could you show a plot of top-1 prediction of "classification network" vs score of "selection network" and elaborate on that?<br><br></td><td>*</td><td>None</td><td>request|experiment</td><td>*</td></tr>
<tr><td>Then, in sections 3.2 and 3.3 the authors introduce a few additional tricks for self-training: exclude datapoints whose predictions are changing and balance the classes.</td><td></td><td>None</td><td>fact</td><td>*</td></tr>
<tr><td>Intuitively, these criteria are well motivated, but unfortunately, the combination of all the intuitions (including "selection network" with threshold) is not very principled.</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>Ablation study shows that the use of the "selection network" strategy does not improve the results without these heuristics.</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>It would be interesting to see how these heuristics would do without "selection network", for example, either by doing simple self-training with thresholding on the score of the classifier or by applying only these heuristics in combination with TempEns+SNTG.</td><td></td><td>None</td><td>request|experiment</td><td>*</td></tr>
<tr><td>In the current form of evaluation, it is hard to say if there is any benefit of using the "selection network" that is the main novelty of the paper.<br><br></td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>It is very valuable that the experimental results include many recently proposed methods.</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>Besides, the settings are described in details that could help for the reproducibility of the results.</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>However, I have a few concerns about the results.</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>First of all, the proposed SST algorithm alone only performs better than baselines in 1 case, equal to them in 1 case and worse in 1 (table 3).</td><td></td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>Besides, as the base classifier is different for various baselines, it is hard to compare the methods.</td><td>@</td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>Then, the important hyperparameter of the method---threshold---seems to be hard to select (both in sections 4.1 and 4.2).</td><td>@</td><td>None</td><td>evaluative</td><td>*</td></tr>
<tr><td>How did you chose the current values? How sensitive is it? Why various datasets need different settings? How the threshold value can be set in practice?</td><td>@</td><td>None</td><td>request|explanation</td><td>*</td></tr>
<tr><td>Another important parameters is the number of iterations of the algorithm.</td><td>@</td><td>None</td><td>request|clarification</td><td>*</td></tr>
<tr><td>How was it chosen?</td><td>@</td><td>None</td><td>request|clarification</td><td>*</td></tr>
<tr><td>Concerning the experiments of section 4.2, how would the baseline methods of section 4.1 do in this case? Why did you select to study animal vs non-animals sets of classes?</td><td>@</td><td>None</td><td>request|explanation</td><td>*</td></tr>
<tr><td>What would happen if you use random class splits or split animal classes (like in a more realistic scenario)?<br><br></td><td>@</td><td>None</td><td>request|explanation</td><td>*</td></tr>
<tr><td>To conclude, while I find the studied problem quite interesting and intuitions behind the method very reasonable, the current methodology is not very principled and the experiment evaluation did not convince me that such an elaborate strategy is needed.<br><br><br><br></td><td></td><td>None</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>Some questions and comments:<br><br></td><td>*</td><td>None</td><td>structuring|heading</td><td>@</td></tr>
<tr><td>- The setting of including unrelated classes in the unlabeled data resembles transfer learning setting. Could you explain why the ideas from transfer learning are not applicable in your case?<br><br></td><td>@</td><td>None</td><td>request|explanation</td><td>@</td></tr>
<tr><td>- In the training procedure of "selection network" of Sections 3.1, do you use the same datapoints to train a "classification network" and "selection network"? If it is the case, how do you insure that the "classification network" does not learn to fit the data perfectly and thus all labels s_i are 1?<br><br></td><td></td><td>None</td><td>request|explanation</td><td>@</td></tr>
<tr><td>- In the last sentences of the first paragraph on p.2 you make a contrast between using softmax and sigmoid functions, however, normally the difference between them is their use in binary or multiclass classification. Is there anything special that you want to show in you case?<br><br></td><td></td><td>None</td><td>request|explanation</td><td>@</td></tr>
<tr><td>- What do you mean in section 3.3 by "if one class dominates the dataset, the model tends to overfit"?<br><br></td><td>*</td><td>None</td><td>request|explanation</td><td>@</td></tr>
<tr><td>- I think parameters of training the networks from the beginning of section 4 could be moved to the supplementary materials.<br><br></td><td></td><td>None</td><td>request|edit</td><td>@</td></tr>
<tr><td>- Figure 3: wouldn't the plot of accuracy vs amount of data be more suitable here?<br><br></td><td>@</td><td>None</td><td>request|explanation</td><td>@</td></tr>
<tr><td>- Synthetic experiments of supplementary materials: the gains of the methods seem to be small. What are the numerical results? What would happen if you allow to select starting point at random (a more realistic case)?<br><br></td><td>*</td><td>None</td><td>request|result</td><td>@</td></tr>
<tr><td>- Can you explain the sentence "To prevent data being added suddenly, no data was added until 5 iterations"?<br><br></td><td>@</td><td>None</td><td>request|explanation</td><td>@</td></tr>
<tr><td>- How was it possible to improve the performance in experiment of section 4.2 with 100% of irrelevant classes?</td><td>*</td><td>None</td><td>request|explanation</td><td>@</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>First of all, thank you for taking your time to review our paper and providing feedback. We have judiciously taken the comments of the reviewers,  and apologize for the late response due to additional experiments and modifications of the paper.<br><br><br><br><br><br></td><td></td><td>None</td><td>social</td><td>*</td></tr>
<tr><td>Remark 1. Expression and detail<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>A : We apologize to the reviewer for the lack of clarity in the manuscript. We have modified our expression.<br><br><br><br><br><br></td><td>*</td><td>None</td><td>concede-criticism</td><td>*</td></tr>
<tr><td>Remark 2.</td><td></td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>What is "Selection Network"?<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>A : It is a module that estimates the confidence of the softmax output according to the inputs of the classification network.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>The selection network is trained with sigmoid and binary cross-entropy in a supervised manner.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>And the threshold is not 0.5 but high because selection network is learned with many ’1’ labels with close to 100 % training accuracy.<br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>The selection network has advantages in out of class unlabeled data.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Since softmax output is a relative value, the softmax output can be high for some out of class unlabeled data.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>In our original paper (in table 10), there already exist results of softmax output for in or out of class unlabeled data with 0.9999 thresholds.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Further, we experimented with the same threshold in table 4 of the new version and the results have shown that out of class unlabeled data are added even with an extremely small threshold such as 0.99999 (epsilon = 10^-5).<br><br><br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Remark 3. "As the base classifier is different for various baselines, it is hard to compare the methods."<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>A : SST has a network structure similar to other papers.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>The difference of structure was that the selection network is added and Gaussian noise and the mean only batch norm are not used.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>As mentioned in the paper (4. Experiments), our supervised learning performs slightly better than conventional SSL algorithms because of different settings such as learning rate and Gaussian noise on the input layer.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>(When SST uses Gaussian noise, ours are also degraded.)<br><br><br><br><br><br></td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Remark 4.</td><td></td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>Experiments Detail ( data setting, threshold, number of iterations, animal vs nonanimal)<br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>A :<br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>==> Data setting<br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>The purpose of experiments is to show that the SST algorithm is comparable to the conventional SSL algorithms.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Therefore, we experimented with the popular setting.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>We have added a detailed description on the data setting to Section 6.3 of the supplementary material.<br><br><br><br><br><br></td><td>@</td><td>None</td><td>done</td><td>@</td></tr>
<tr><td>==> Iterations & Threshold<br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>We have missed out on a detailed description of how to set up some hyper-parameters.</td><td>@</td><td>None</td><td>concede-criticism</td><td>@</td></tr>
<tr><td>We set parameters as follows.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>The number of training iteration and thresholding epsilon are very important parameters in our algorithm and have a considerable correlation with each other.<br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>In the first experiment, the iteration number remains fixed and the growth rate of epsilon is adjusted so that the validation accuracy saturates near the settled iteration number.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>While the validation accuracy is evaluated using the cross-validation, we set the number of training iteration to be 100 so that the model is trained enough until it saturates.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Epsilon is increased in log-scale and begins at a very small value (10^(−5)) where no data is added.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>The growth rate of epsilon is determined according to when the validation accuracy saturates.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>The stopping criterion is that the accuracy of the current iteration reaches the average accuracy of the previous 20 steps.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>If the stopping iteration is much less than 100 times, the epsilon growth rate should be reduced so that the data is added more slowly.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>If the stopping iteration significantly exceeds 100 iterations, the epsilon growth rate should be increased so that the data is added more easily.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>We allow 5 iterations as a deviation from 100 iterations and the growth rate of epsilon is left unchanged in this interval.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>(In previous versions, the growth ratio of epsilon for CIFAR-10 was applied to SVHN and CIFAR-100.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>However, since the epsilon growth rate is different for each dataset, as the reviewer mentioned, we have performed the cross-validation for SVHN and CIFAR-100 and modified our results.) As a result, the epsilon is gradually increased in log-scale by 10 times every 33 iterations in CIFAR-10 and SVHN.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>In the case of CIFAR-100, the epsilon is increased by 10 times in log-scale every 27 iterations.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>In the second experiment, we leave the epsilon fixed and simply train the model until the stopping criterion is satisfied.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Other details are the same as those of the first experiment.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>(In previous versions, the training iterations of fixed mode had been fixed.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Thanks to the comment from the reviewer, we were able to rearrange the content and set training iteration by cross-validation.)<br><br><br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>=</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>=> Animal vs non-animal<br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>The citation of that part is obscure and has been modified.</td><td>@</td><td>None</td><td>done</td><td>@</td></tr>
<tr><td>We experimented similar to the [1] and they categorized according to the animal.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Our approach is similar but not identical.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Their unlabeled data came from only in 4 classes, however, we selected unlabeled data in all classes.<br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>[1] Odena, Augustus, et al. "Realistic Evaluation of Semi-Supervised Learning Algorithms." (2018)<br><br><br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>Some Questions and comments<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>Remark 5. "The setting of including unrelated classes in the unlabeled data resembles transfer learning setting. Could you explain why the ideas from transfer learning are not applicable in your case?"<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>A : To the best of our knowledge, the main purpose of transfer learning is to improve the performance on the target domain by effectively utilizing the knowledge of the source domain.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>However, in our case, there is no separated source and target domains.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>We focus on the single classification task.</td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>We think that the goal of our method and that of transfer learning are quite different.<br><br><br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Remark 6. "What do you mean in section 3.3 by "if one class dominates the dataset, the model tends to overfit"?"<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>@</td></tr>
<tr><td>A " We have modified that expression and we wanted to address that "if one class dominates the dataset, the performances are degraded by the imbalanced distribution.</td><td>*</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>(Analysing the classification of imbalanced data-sets with multiple classes: Binarization techniques and ad-hoc approaches, 2013)"<br><br><br><br><br><br></td><td>*</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Remark 7. "Figure 3: wouldn’t the plot of accuracy vs amount of data be more suitable here?"<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>A : I agree that your suggestion is more suitable for the figure.</td><td>@</td><td>None</td><td>done</td><td>*</td></tr>
<tr><td>However, it is difficult to show the figure you want because the number of selected samples is different every time.<br><br><br><br><br><br></td><td>@</td><td>None</td><td>reject-request</td><td>*</td></tr>
<tr><td>Remark 8. "Synthetic experiments of supplementary materials: the gains of the methods seem to be small. What are the numerical results? What would happen if you allow to select starting point at random (a more realistic case)?"<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>A : The performance depends on the initial points, therefore sometimes the performance is not good. Since the inputs are the x and y coordinate values, it can be very easy to add to the training set.</td><td>*</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>(ex.. class 1 : (-1, 0), (1, 0) , class 2 : (0.5, -0.5), (1.5, -0.5) , then decision boundary could be (:, -0.25) then class 2 unlabeled data (0, 0.5) is classified as class 1 and can have a very high selection score.)<br><br><br><br><br><br></td><td>*</td><td>None</td><td>answer</td><td>@</td></tr>
<tr><td>Remark 9. Can you explain the sentence "To prevent data being added suddenly, no data was added until 5 iterations"?<br><br><br><br></td><td>@</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>A : In fixed mode, we ensemble the selection scores, which makes the prediction more consistent.</td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Also, for a more reliable selection score, we do not add unlabeled data to the new training set and train with labeled data only for 5 iterations.<br><br><br><br><br><br></td><td>@</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>Remark 10. "How was it possible to improve the performance in the experiment of section 4.2 with 100% of irrelevant classes?"<br><br><br><br></td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>A : We suspect that this performance improvement is due to re-initializing learning rate.</td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>After constructing a new training dataset, we retrain our model with the learning rate of the initial value.</td><td>*</td><td>None</td><td>structuring</td><td>*</td></tr>
<tr><td>In decay mode (Figure 2, Figure 3 (a) and (b) of the original manuscript), the accuracy is slightly increased and gets saturated while unlabeled data is not being added.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>However, the accuracy begins to increase or decrease relatively more after adding selected data to the new training dataset.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>In fixed mode (Figure 3 (c) and (d) of the original manuscript), the improvement with the 100% of irrelevant classes seems to be due to re-initializing learning rate.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr>
<tr><td>However, SST algorithm with other ratios of out-of-class samples results in performance improvement compared to the 100% because out-of-class samples are not selected.</td><td>*</td><td>None</td><td>answer</td><td>*</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

 <h2 class="title is-2"> Segmentations for H1gOvMYT37 </h2>
 <div class="columns">
    <div class="column">
       <div class="card">
          <div class="card-content">
             <div class="content">
                <h3 class="title is-3"> Review </h3><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>* Summary<br><br></td><td></td><td></td><td>structuring|heading</td><td>*</td></tr>
<tr><td>This paper addresses machine reading tasks involving tracking the states of entities over text.</td><td></td><td>5 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>To this end, it proposes constructing a knowledge graph using recurrent updates over the sentences of the text, and using the graph representation to condition a reading comprehension module.</td><td></td><td>10 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>The paper reports positive evaluations on three different tasks.<br><br><br><br></td><td></td><td>9 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>* Review<br><br><br><br></td><td></td><td>9 poss. segments</td><td>structuring|heading</td><td>*</td></tr>
<tr><td>This is an interesting paper.</td><td></td><td>9 poss. segments</td><td>evaluative</td><td>*</td></tr>
<tr><td>The key technical component in the proposed approach is the idea that keeping track of entity states requires (soft) coreference between newly read entities and locations and the ones existing in the knowledge graph constructed so far.<br><br><br><br></td><td></td><td>8 poss. segments</td><td>structuring|summary</td><td>*</td></tr>
<tr><td>The proposed method seems plausible, but some details are impressionistic and it is not clear why and whether the modeling choices do what the paper says.</td><td>*</td><td>10 poss. segments</td><td>evaluative</td><td>@</td></tr>
<tr><td>This is especially the case in a few places involving coreference:<br><br></td><td>*</td><td>10 poss. segments</td><td>fact</td><td>@</td></tr>
<tr><td>1. The paper says at the top of page 6 that the result of Eq 1 is a disambiguated intermediate node representation.<br><br></td><td>*</td><td>10 poss. segments</td><td>structuring|quote</td><td>@</td></tr>
<tr><td>2. The self attention in Eq 2 performs coreference disamguation which prevents different instances of the same location from being predicted for multiple entities.<br><br><br><br></td><td>*</td><td>9 poss. segments</td><td>structuring|quote</td><td>@</td></tr>
<tr><td>While these may indeed be working as advertised, it would be good to see some evaluation that verifies that after learning, what is actually happening is coreference.<br><br><br><br></td><td>*</td><td>8 poss. segments</td><td>request|result</td><td>@</td></tr>
<tr><td>Why does the graph update require coreference pooling again?</td><td>@</td><td>6 poss. segments</td><td>request|explanation</td><td>*</td></tr>
<tr><td>Don't the updates in Eq 1 and 2 take care of this? The ablation does not test this, right?<br><br><br><br></td><td>@</td><td>paper|text|modeling|choices</td><td>request|explanation</td><td>*</td></tr>
<tr><td>Another modeling choice that is not clear is regarding how the model processes the text -- reading prefixes of the paragraph, rather than one sentence at a time. What happens if the model is changed to be read one sentence at a time?<br><br><br><br></td><td>*</td><td>paper|modeling|choices|model</td><td>request|explanation</td><td>*</td></tr>
<tr><td>That the model implicitly learns constraints from data is interesting!<br><br><br><br></td><td></td><td>paper|modeling|choices</td><td>evaluative</td><td>*</td></tr>
<tr><td>Bottomline: The paper presents interesting ideas and good results, but would be better if the modeling choices were better explored/motivated.</td><td></td><td></td><td>structuring|summary</td><td>*</td></tr></table><h3 class="title is-3"> Rebuttal </h3>Rebuttal <br><table class="table"><thead> <td> Sentence </td><td>alignment</td> <td>entity_grid</td> <td>label</td> <td>text_tiling</td></thead>
<tr><td>Thanks for the insightful comments.</td><td></td><td>comments</td><td>social</td><td>*</td></tr>
<tr><td>We’ve tried to improve our paper based on your feedback.</td><td></td><td>comments|we|paper</td><td>social</td><td>*</td></tr>
<tr><td>Most significantly, we’ve performed additional ablation studies to confirm that our modeling choices improve performance, and we provide further empirical insight on what the coreference operations do.</td><td></td><td>10 poss. segments</td><td>summary</td><td>*</td></tr>
<tr><td>We’ve also updated the model description and the notation in Section 4 to clarify modeling mechanisms and choices.</td><td></td><td>13 poss. segments</td><td>summary</td><td>*</td></tr>
<tr><td>Two important additions are a high-level summary of the model, which we give at the beginning of Section 4, and a table (Table 2) that lists what each symbol represents along with its dimensions.</td><td></td><td>13 poss. segments</td><td>summary</td><td>*</td></tr>
<tr><td>Below we address your concerns point-by-point.<br><br><br><br></td><td></td><td>13 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>The proposed method seems plausible, but some details are impressionistic and it is not clear why and whether the modeling choices do what the paper says.</td><td>*</td><td>14 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>This is especially the case in a few places involving coreference:<br><br></td><td>*</td><td>14 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>1. The paper says at the top of page 6 that the result of Eq 1 is a disambiguated intermediate node representation.<br><br></td><td>*</td><td>16 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>2. The self attention in Eq 2 performs coreference disamguation which prevents different instances of the same location from being predicted for multiple entities.<br><br></td><td>*</td><td>20 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>While these may indeed be working as advertised, it would be good to see some evaluation that verifies that after learning, what is actually happening is coreference.<br><br></td><td>*</td><td>19 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>======<br><br></td><td>*</td><td>19 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Based on your comments, we’ve performed additional ablations to measure the impact of the co-reference mechanisms.</td><td>*</td><td>18 poss. segments</td><td>done</td><td>@</td></tr>
<tr><td>We find that removing any of them leads to a decrease in performance (Rows 2, 3, 4 of Table 5).<br><br><br><br></td><td>*</td><td>17 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>To provide more than just this quantitative insight, we’ll expand here on how KG-MRC handles coreference to better motivate the modeling choices:<br><br></td><td>*</td><td>16 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>The construction of graph G_t from G_{t-1} uses co-reference disambiguation of nodes to prevent node duplication and to enforce temporal dependencies.</td><td>*</td><td>21 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>We perform coreference disambiguation between location nodes of G_t and G_{t-1} via Eq. 1 (call this inter-graph coreference) and between the location nodes in the same graph Gt (call this intra-graph coreference) via Eq. 2.</td><td>*</td><td>21 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>The inter-graph coreference yields new, intermediate representations for the nodes in G_t.</td><td>*</td><td>21 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>These are further updated via the intra-graph coreference step.<br><br><br><br></td><td>*</td><td>22 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Inter-graph Co-ref: One way to think about this is that we construct a new graph G_t at every time step.</td><td>*</td><td>23 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Now the graph G_{t-1} might contain some location nodes which are predicted again at time step ‘t’ (e.g., in Figure 2, leaf node already existed in G_{t-1}).</td><td>*</td><td>24 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Instead of replacing an old node with an entirely new node at ‘t’, we take a recurrent approach and do a gated update that preserves some information stored in the node in previous time steps while adding new information unique to time step ‘t’.<br><br><br><br></td><td>*</td><td>26 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Intra-graph Co-ref: Inter-graph co-ref isn’t enough since the MRC module makes its span predictions independently.</td><td>*</td><td>26 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>This means that, at time step t, the model could predict the same span/location for multiple entities and add all these duplicates to the graph.</td><td>*</td><td>25 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Moreover, a single location might have the same surface form but be from different parts of the paragraph (e.g. “leaf” in the 1st and the 5th sentence of the para in figure 2).</td><td>*</td><td>26 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>The operations in Eq. 2 resolve this by performing self-attention (i.e., the predicted locations of all entities are compared to each other).<br><br></td><td>*</td><td>25 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>=====<br><br><br><br></td><td></td><td>25 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>Response continued from above.<br><br><br><br></td><td></td><td>25 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Why does the graph update require coreference pooling again?</td><td>@</td><td>25 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Don't the updates in Eq 1 and 2 take care of this? The ablation does not test this, right?<br><br></td><td>@</td><td>26 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>=====<br><br></td><td>@</td><td>26 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>We agree that the coreference pooling in the graph update seems repetitive at first glance.</td><td>@</td><td>26 poss. segments</td><td>concede-criticism</td><td>@</td></tr>
<tr><td>We have further clarified the explanation given in the text and included another ablation experiment  (row 4 of Table 5) to confirm its usefulness.</td><td>@</td><td>25 poss. segments</td><td>done</td><td>@</td></tr>
<tr><td>This step does indeed repeat Eq. 2.</td><td>@</td><td>25 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>In a nutshell, this is necessary because, after the recurrent and residual graph updates (Eqs 3.1 - 3.3) that propagate information across edges, we may end up with different representations for location nodes corresponding to the same location.</td><td>@</td><td>24 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>We don’t want these representations to diverge from each other because of information propagation.<br><br><br><br></td><td>@</td><td>25 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>To give you more detail:<br><br></td><td>@</td><td>25 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>The graph update step ensures information propagation between entities and location representations.</td><td>@</td><td>23 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Specifically if the current location of entity “e_t” is predicted as “\lambda_t”, the graph update steps ensures that both the entity and location representation gets the same update (via eq 3.2 and 3.3).</td><td>@</td><td>22 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>This would have been sufficient if every entity had a unique location.</td><td>@</td><td>22 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>But, multiple entities can actually exist in the same location.</td><td>@</td><td>21 poss. segments</td><td>answer</td><td>@</td></tr>
<tr><td>Let’s consider this small graph below<br><br><br><br></td><td>@</td><td>20 poss. segments</td><td>structuring</td><td>@</td></tr>
<tr><td>Water - -> leaf<br><br></td><td>@</td><td>21 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>CO_2 --> leaf<br><br><br><br></td><td>@</td><td>22 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Here both water and CO_2 exist in the same location, leaf.</td><td>@</td><td>22 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>But let’s say that the MRC model picked the “leaf” span from sentence 1 (of the text in Fig 2) for “Water” and from sentence 4 for CO_2.</td><td>@</td><td>20 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>In reality, they refer to the same location entity “leaf”.</td><td>@</td><td>19 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Now, due to eq. 3.3, the two embeddings of leaf will get two different residual updates (one would be corresponding to Water and other would be because of CO_2).</td><td>@</td><td>17 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Because of the different updates, the two representations of the same entity might diverge.</td><td>@</td><td>14 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>To remedy this, we re-use the coreference matrix “U” we create in eq. (2), which should already have a high attention score corresponding to the two leaf locations.</td><td>@</td><td>9 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>Thus we perform a similar operation to the intra-graph update.<br><br></td><td>@</td><td>8 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>====<br><br></td><td></td><td>8 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>Another modeling choice that is not clear is regarding how the model processes the text -- reading prefixes of the paragraph, rather than one sentence at a time. What happens if the model is changed to be read one sentence at a time?<br><br></td><td>*</td><td>9 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>====<br><br></td><td>*</td><td>9 poss. segments</td><td>structuring</td><td>*</td></tr>
<tr><td>The “prefixes” that our model reads at each time step comprise all sentences up to and including the current sentence s_t.</td><td>*</td><td>11 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>The motivation for this modeling choice was empirical.</td><td>*</td><td>9 poss. segments</td><td>answer</td><td>*</td></tr>
<tr><td>In our preliminary experiments we evaluated alternative strategies, such as (a) only considering the current sentence s_t, and (b) considering the entire paragraph at every time step.</td><td>*</td><td>we|model|prefixes|sentences</td><td>answer</td><td>*</td></tr>
<tr><td>We found that operating on prefixes performed best.</td><td>*</td><td>model|prefixes|sentences</td><td>answer</td><td>*</td></tr>
<tr><td>This is in line with the findings of Dalvi et al., 2018, where the Pro-Global model (which uses prefixes) performs better than the Pro-Local model (which operates on single sentences).</td><td>*</td><td></td><td>answer</td><td>*</td></tr></table>
             </div>
          </div>
       </div>
    </div>
 </div>

</div>
   </body>
</HTML>

